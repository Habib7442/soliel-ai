[
  {
    "projectId": "5cafc0bb-489f-4bd8-b9e4-18c9aadc6e13",
    "testId": "29b800a5-a6cb-4669-98ad-5aea2ffad286",
    "userId": "84c88498-f061-70d5-9d54-ca66a0123668",
    "title": "TC012-Admin Dashboard and Role-Based Access Control",
    "description": "Ensure role-based access properly restricts or permits access to dashboards and features for students, instructors, company admins, and super admins.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Get Started Now' button (or equivalent) to reach the sign-in / authentication page so logins can be performed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/section[1]/div[3]/div/div[1]/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Sign In' link to open the authentication page so role logins can be performed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/header/div/div/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the authentication (Sign In) page so role logins can be performed by clicking the Sign In element.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/header/div/div/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Log in as Super Admin using provided admin credentials to access the Admin Dashboard (first step before verifying TC012, TC013, TC014).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('guest74427@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div[2]/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Guest7442@')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Log out of the Super Admin account to return to the sign-in page, then proceed to log in as the Student account (use example@gmail.com / password123 per test-login guidance if specific test student credentials are not available). After Student login, verify Student Dashboard restricts admin/instructor features.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/header/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Confirm sign out by clicking the 'Yes, Sign Out' button to return to the sign-in page, then log in as the Student user (use example@gmail.com / password123) and verify Student dashboard restrictions.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[5]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the sign-in page (since current page has no interactive elements) so the Student login can be performed.\n        await page.goto(\"http://localhost:3000/sign-in\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Log in as the Student user and reach the Student Dashboard to verify student-specific access and that instructor/company/admin features are restricted.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div[2]/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the sign-up/register flow to create or obtain a test Student account (click 'Create Account') so a Student Dashboard can be accessed and verified.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the registration (Create Account) flow so a test Student account can be created. Click the 'Create Account' button to reveal the signup form/modal.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Create a test Student account by filling the sign-up form (Full Name, Email, Password) and submit the form to create the account, then proceed to verify Student Dashboard access/restrictions.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div[2]/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Student')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('student_test@example.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div[2]/form/div[3]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        # -> Submit the Create Account form (click 'Get Started') to create the Student account and then verify the Student Dashboard loads and role-based restrictions are enforced.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Wait for the sign-up processing to finish, then navigate to the Sign In page and attempt to log in as the newly created student to verify the Student Dashboard and role-based restrictions.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Correct the student's email (remove underscore) to studenttest@example.com and resubmit the Create Account form to complete student registration (then proceed to sign-in and verify Student Dashboard).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('studenttest@example.com')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Attempt to sign in as the Student using the Sign In form on the current page and verify whether the Student Dashboard loads.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('studenttest@example.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div[2]/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Log in as Super Admin at the current sign-in page using guest74427@gmail.com / Guest7442@ and verify Admin Dashboard elements required for TC012 (Admin Dashboard), TC013 (Course Approval), and TC014 (Analytics/Reports).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('guest74427@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div[2]/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Guest7442@')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Sign out of the Super Admin session so the sign-in / create-account flows can be used to create/test Instructor and Company Admin accounts and then perform role logins and access assertions.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/header/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Confirm sign out by clicking 'Yes, Sign Out' so the session ends and the sign-in/create-account flows can be used to attempt Instructor and Company Admin tests (or to reopen sign-in).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[5]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Sign In page, log in as Super Admin, then use Admin 'Manage Users' or Admin UI to create verified Instructor and Company Admin accounts (to avoid repeated failing public sign-up attempts). Start by clicking the 'Sign In' link to open authentication.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/header/div/div/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Sign In/authentication page so Super Admin can sign in and then use Admin 'Manage Users' to create verified Instructor and Company Admin accounts. Immediate action: click the Sign In link on the homepage.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/header/div/div/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Reload the Sign In page to restore interactive elements so Super Admin can sign in and then create verified Instructor and Company Admin accounts from Admin > Manage Users.\n        await page.goto(\"http://localhost:3000/sign-in\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84c88498-f061-70d5-9d54-ca66a0123668/177026696435275//tmp/test_task/result.webm",
    "created": "2026-02-05T04:35:11.237Z",
    "modified": "2026-02-05T04:49:24.549Z"
  },
  {
    "projectId": "5cafc0bb-489f-4bd8-b9e4-18c9aadc6e13",
    "testId": "b62a042c-63c4-4e16-a8b1-fd982e5bcd37",
    "userId": "84c88498-f061-70d5-9d54-ca66a0123668",
    "title": "TC013-Admin Course Approval Workflow",
    "description": "Test the workflow for admins to review, approve, reject, unpublish, and delete courses through the Admin Dashboard.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the sign-in page or trigger the sign-in flow (click 'Get Started Now' to reach the sign-in/signup flow).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/section[1]/div[3]/div/div[1]/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Sign In' link (index=1660) to open the sign-in page, then log in with guest74427@gmail.com / Guest7442@.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/header/div/div/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Sign In' link (index=1660) again to open the sign-in page so the login form can be filled.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/header/div/div/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Wait briefly for the sign-in page to load; if still empty, reload the sign-in URL to force the SPA to initialize. After page loads, locate email and password inputs and the Sign In button to perform login.\n        await page.goto(\"http://localhost:3000/sign-in\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill email and password with admin credentials and submit the sign-in form to log in as super admin (guest74427@gmail.com / Guest7442@). After login, proceed to Admin Courses management.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('guest74427@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div[2]/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Guest7442@')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Enter Dashboard' button (submit) using the current page's submit element (index=3044) to attempt login with the filled credentials.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Re-enter the email and password into the visible fields to ensure they are populated, then click 'Enter Dashboard' to attempt login again.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('guest74427@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div[2]/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Guest7442@')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Admin Courses management page from Quick Management to select pending course submissions.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[2]/div[2]/div/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open Admin Courses management by clicking the 'Courses - Content & reviews' quick management card (index=3505) so pending course submissions can be selected.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[2]/div[2]/div/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Select a pending course submission (open its review/detail view) so the review actions (approve/reject) can be performed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[2]/div[2]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the pending course 'Automated Test Course - Intro to Testing' (Draft) to view its review/detail page so review actions (approve/reject) can be performed next.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[2]/div[2]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the on-page 'Re-publish' button for the pending course to approve/publish it (use button index 4450).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[2]/div[2]/div/table/tbody/tr[1]/td[6]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Approved').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test attempted to verify that the selected pending course was approved and became live after clicking 'Re-publish', but the page did not display an 'Approved' status or any indication the course is live.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Summary of actions and findings:\n- Logged in as super admin (guest74427@gmail.com).\n- Opened Admin Courses and inspected course list; visible course data and admin action buttons were extracted and saved (extracted_content_0.md and extracted_content_1.md).\n- Opened the pending course 'Automated Test Course - Intro to Testing' and reviewed details (extracted_content_1.md).\n- Clicked 'Re-publish' (Approve) for that course (button index 4450). Browser displayed approval confirmation dialogs (auto-closed). The course row now shows 'Published' status, indicating the approve/publish action likely succeeded.\nIssues/notes:\n- Earlier intermittent/stale element failures occurred (sign-in click index=147 failed once; submit index=2713 failed once). Avoid reusing those exact indexes.\n- Multiple auto-closed confirm dialogs were recorded (approval confirmations). No visible error toasts were present after the action.\nFiles produced:\n- extracted_content_0.md\n- extracted_content_1.md\nNext recommended step (not executed because user asked to stop): verify the course is live in the public catalog (open the course Preview/View or search the catalog) and then continue with the remaining workflow steps: reject another pending course with a reason, verify rejection, unpublish a live course, verify unpublish, delete a course, and verify deletion.\nOverall task completion status: The specific requested on-page 'Re-publish' action was performed successfully. The full workflow test (all steps) was not completed.\n\n\nAttachments:\n\nextracted_content_0.md:\n<url>\nhttp://localhost:3000/admin-courses\n</url>\n<query>\nFrom the Admin Courses page currently visible, list all visible courses with: title, instructor name, instructor email, price, and any admin feedback shown. For each course indicate if it appears to be pending review (e.g., shows 'Admin Feedback' or lacks Published/Live markers). Provide the exact text snippets shown for admin feedback and the course titles to identify which course to open next.\n</query>\n<result>\n1) Title (exact): Automated Test Course - Intro to Testing  A short description for the automated test course used in end-to-end testing.\n   - Instructor name: Habib\n   - Instructor email: habibtanwir1906@gmail.com\n   - Price: $0.00\n   - Status (as shown): Draft\n   - Admin feedback (exact): (none shown)\n   - Pending review: Yes (lacks Published/Live marker — Status is \"Draft\")\n\n2) Title (exact): Introduction to Artificial intelligence  Introduction to Artificial Intelligence is a beginner-friendly course designed to help learners understand the fundamentals of AI and how it is transforming the world.\n   - Instructor name: Habib\n   - Instructor email: habibtanwir1906@gmail.com\n   - Price: $0.00\n   - Status (as shown): Published\n   - Admin feedback (exact): (none shown)\n   - Pending review: No (Status is \"Published\")\n\n3) Title (exact): figmaaaaa  figma figma figma figma figma figma figma figma figma figma figma figma figma figma figma figma figma figma figma figma figma figma figma figma figma\n   - Instructor name: Joyin\n   - Instructor email: joyinlaskar@gmail.com\n   - Price: $50.00\n   - Status (as shown): Published\n   - Admin feedback (exact): (none shown)\n   - Pending review: No (Status is \"Published\")\n\n4) Title (exact): developemnt  demo web dev  Admin Feedback:  video quality needs to improve\n   - Instructor name: Joyin\n   - Instructor email: joyinlaskar@gmail.com\n   - Price: $200.00\n   - Status (as shown): Rejected\n   - Admin feedback (exact): Admin Feedback:  video quality needs to improve\n   - Pending review: Yes (shows \"Admin Feedback\" and is not Published)\n\n5) Title (exact): Demo course 3  Demo course 3\n   - Instructor name: Habib\n   - Instructor email: habibtanwir1906@gmail.com\n   - Price: $10.00\n   - Status (as shown): Published\n   - Admin feedback (exact): (none shown)\n   - Pending review: No (Status is \"Published\")\n\n6) Title (exact): React & Next.js — Build Production-Ready Web Apps by habib  Learn React fundamentals and Next.js for SSR/SSG to build fast, SEO-friendly, production web apps — includes 2 real projects.\n   - Instructor name: Habib\n   - Instructor email: habibtanwir1906@gmail.com\n   - Price: $100.00\n   - Status (as shown): Published\n   - Admin feedback (exact): (none shown)\n   - Pending review: No (Status is \"Published\")\n</result>\n\nextracted_content_1.md:\n<url>\nhttp://localhost:3000/admin-courses\n</url>\n<query>\nFrom the currently opened course detail/preview for 'Automated Test Course - Intro to Testing', extract the following exactly as shown on the page: 1) Course title (exact text). 2) Full course description and any long content (syllabus/sections) visible. 3) Instructor name and instructor email. 4) Price shown. 5) Current status (Draft / Pending / Published / Rejected / etc.) and any visible Admin Feedback text (exact snippet). 6) Any on-page admin controls for review (Approve, Reject, Unpublish, Delete, or similar) — list their visible labels/text and describe their approximate location on the page (e.g., top-right, under course header) so the next step can target the correct interactive element index. 7) Include any visible confirmation messages, toasts, or validation hints present. Provide the extracted content exactly as displayed.\n</query>\n<result>\n1) Course title (exact text):\nAutomated Test Course - Intro to Testing\n\n2) Full course description and any long content (syllabus/sections) visible (exact text):\nA short description for the automated test course used in end-to-end testing.\n\n3) Instructor name and instructor email (exact text):\nInstructor name: Habib\nInstructor email: habibtanwir1906@gmail.com\n\n4) Price shown (exact text):\n$0.00\n\n5) Current status and any visible Admin Feedback text (exact text):\nStatus: Draft\nAdmin Feedback: (none visible on the page)\n\n6) On-page admin controls for review — visible labels/text and approximate location (exact text and location):\nVisible labels/text (exactly as displayed): ViewRe-publishRejectDelete\nApproximate location: Actions column — rightmost cell of the course's table row for \"Automated Test Course - Intro to Testing\" (buttons/controls appear in this Actions column in left-to-right order: View → Re-publish → Reject → Delete)\n\n7) Visible confirmation messages, toasts, or validation hints (exact text or note if not present):\nNo confirmation messages, toasts, or validation hints are visible on the page.\n</result>",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84c88498-f061-70d5-9d54-ca66a0123668/1770266690594533//tmp/test_task/result.webm",
    "created": "2026-02-05T04:35:11.254Z",
    "modified": "2026-02-05T04:44:50.776Z"
  },
  {
    "projectId": "5cafc0bb-489f-4bd8-b9e4-18c9aadc6e13",
    "testId": "1471d0b4-96f8-4862-a884-8d76e818c86c",
    "userId": "84c88498-f061-70d5-9d54-ca66a0123668",
    "title": "TC014-Admin Analytics Reports Accuracy",
    "description": "Verify that admin analytics and reporting components display accurate aggregated data for revenue, user growth, course performance, and employee learning statistics.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Sign In' link to open the login page so admin credentials can be entered.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/header/div/div/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the sign-in page (navigate to /sign-in) and begin login by filling the email and password fields with the provided admin credentials.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/header/div/div/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields with the provided admin credentials and click 'Enter Dashboard' to log in.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div[2]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('guest74427@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div[2]/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Guest7442@')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Reports' (Analytics & insights) link (interactive element [2205]) to open the Admin Reports Dashboard so revenue, user growth, course performance, and employee learning analytics can be inspected.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[2]/div[2]/div/a[6]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Reports (Analytics & insights)' link to open the Admin Reports Dashboard so analytics widgets for revenue, user growth, course performance, and employee learning can be inspected.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[2]/div[2]/div/a[6]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Reload the /admin-reports page (since no interactive elements are present) to force the SPA to render, then locate analytics widgets for revenue, user growth, course performance, and employee learning so the assertions can be performed.\n        await page.goto(\"http://localhost:3000/admin-reports\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Total Revenue').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected the Admin Reports Dashboard to display aggregated analytics — specifically the 'Total Revenue' metric. The dashboard did not show the revenue summary, so revenue aggregation (and possibly other report widgets like user growth, course performance, and employee learning) failed to load or was incorrect.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Summary of findings and validation (extracted values and checks):\n\n1) Extracted metrics (raw JSON):\n{\n  \"total_revenue\": \"$928.00\",\n  \"total_revenue_change_text\": \"+12.5%vs last month\",\n  \"revenue_breakdown\": {\n    \"individual_sales_amount\": \"$400.00\",\n    \"individual_sales_count\": \"3 single course purchases\",\n    \"bundle_sales_amount\": \"$528.00\",\n    \"bundle_sales_count\": \"3 course bundle purchases\",\n    \"corporate_sales_amount\": \"$0.00\",\n    \"corporate_sales_count\": \"0 B2B enterprise deals\"\n  },\n  \"revenue_trend\": [\n    { \"month\": \"Sep 2025\", \"amount\": \"$0.00\" },\n    { \"month\": \"Oct 2025\", \"amount\": \"$0.00\" },\n    { \"month\": \"Nov 2025\", \"amount\": \"$0.00\" },\n    { \"month\": \"Dec 2025\", \"amount\": \"$928.00\" },\n    { \"month\": \"Jan 2026\", \"amount\": \"$0.00\" },\n    { \"month\": \"Feb 2026\", \"amount\": \"$0.00\" }\n  ],\n  \"total_students\": \"3\",\n  \"students_delta_text\": \"+0this month\",\n  \"total_enrollments\": \"4\",\n  \"across_courses_text\": \"Across 4 courses\",\n  \"certificates_issued\": \"1\",\n  \"certificates_delta_text\": \"+0this month\",\n  \"tabs\": [\"Revenue\",\"Students\",\"Courses\",\"Certificates\"]\n}\n\n2) Validation results (internal consistency checks):\n- Total Revenue vs Revenue Breakdown: PASS\n  - Calculation: $400.00 (Individual) + $528.00 (Bundle) + $0.00 (Corporate) = $928.00\n  - Matches displayed total_revenue: $928.00.\n\n- Total Revenue vs Revenue Trend (last 6 months): PASS\n  - Sum of revenue_trend months = $0 + $0 + $0 + $928.00 + $0 + $0 = $928.00\n  - Matches displayed total_revenue: $928.00.\n\n- Revenue counts vs enrollments/students: INCONCLUSIVE (acceptable difference explained)\n  - Displayed purchase counts: individual 3 purchases, bundle 3 purchases (total purchases shown = 6). Displayed total_enrollments = 4 and total_students = 3.\n  - These metrics measure different things (purchase transactions vs course enrollments vs unique students). On-screen values are internally consistent (no arithmetic mismatch), but a difference between 'number of purchases' and 'enrollments' can be expected (bundles may count multiple courses per purchase or some purchases may not map 1:1 to enrollments). Cannot assert an error without backend semantics.\n\n- Total Students / Total Enrollments / Across X courses: PASS (internal consistency)\n  - total_enrollments = \"4\" and across_courses_text = \"Across 4 courses\" -> consistent on-screen.\n  - total_students = \"3\" with delta text \"+0this month\" (displayed) -> no on-screen contradiction.\n\n- Certificates issued: PASS (internal consistency)\n  - certificates_issued = \"1\" and certificates_delta_text = \"+0this month\" -> consistent.\n\n3) Checks that cannot be fully verified from the UI alone (external verification required):\n- Check that total_revenue matches payment gateway / transaction records: UNABLE_TO_VERIFY\n  - Reason: UI displays aggregated totals but payment records or database transaction logs are required to confirm accuracy against source of truth.\n\n- Validate user growth charts against registration/auth logs or active user DB: UNABLE_TO_VERIFY\n  - Reason: only summary numbers are visible. Complete verification requires access to raw registration and active-user data.\n\n- Confirm course performance metrics (completion rates, ratings): UNABLE_TO_VERIFY\n  - Reason: the Courses tab content (completion rates/ratings) was not extracted. These metrics require visiting the Courses tab or database for cross-check.\n\n- Verify employee learning analytics for corporate accounts: UNABLE_TO_VERIFY\n  - Reason: corporate/employee learning data (corporate accounts, assigned learners, progress) are not shown on the visible Revenue tab. Backend or corporate-accounts-specific UI views are needed.\n\n4) Recommendations / next steps to fully complete verification (actions that will be required):\n- Provide payment gateway/transaction export or DB access to reconcile displayed revenue with actual transactions (for TC014 total revenue validation).\n- Extract and inspect the 'Students' and 'Courses' tabs content programmatically (click tabs [3785] and [3786]) to fetch user-growth charts, completion rates and ratings.\n- For corporate / employee learning verification: open corporate accounts view or the corporate/Employees analytics panel, or provide corporate enrollment/progress records.\n- Use the Export Report button (interactive [3719]) to download raw aggregated CSV/JSON if available and reconcile programmatically.\n\n5) Conclusion / task completion status:\n- The UI-level validations that can be performed from the loaded Admin Reports page were completed: internal consistency checks for revenue and on-screen labels PASS.\n- External verifications (reconciling to payment/registration databases and course completion records) could not be performed with only the current UI and without access to source data.\n\nFinal status: success=false (Reason: full verification against underlying payment/registration/course data could not be completed with UI data alone. Internal consistency checks PASS.)\n\nIf full verification is required, please provide one or more of the following: payment/transaction export, registration/active-user export, course completion/rating exports, or permission to navigate and extract the Students/Courses/Certificates tab details and corporate account analytics. The agent can then run the additional checks and complete the verification.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84c88498-f061-70d5-9d54-ca66a0123668/1770266497020821//tmp/test_task/result.webm",
    "created": "2026-02-05T04:35:11.264Z",
    "modified": "2026-02-05T04:41:37.222Z"
  }
]
